{"ast":null,"code":"/** @license React vundefined\n * react-cache.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function () {\n    'use strict';\n\n    Object.defineProperty(exports, '__esModule', {\n      value: true\n    });\n\n    var React = require('react');\n\n    var Scheduler = require('scheduler');\n\n    var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED; // Prevent newer renderers from RTE when used with older react package versions.\n    // Current owner and dispatcher used to share the same ref,\n    // but PR #14548 split them out to better support the react-debug-tools package.\n\n    if (!ReactSharedInternals.hasOwnProperty('ReactCurrentDispatcher')) {\n      ReactSharedInternals.ReactCurrentDispatcher = {\n        current: null\n      };\n    }\n\n    if (!ReactSharedInternals.hasOwnProperty('ReactCurrentBatchConfig')) {\n      ReactSharedInternals.ReactCurrentBatchConfig = {\n        suspense: null\n      };\n    }\n\n    function error(format) {\n      {\n        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          args[_key2 - 1] = arguments[_key2];\n        }\n\n        printWarning('error', format, args);\n      }\n    }\n\n    function printWarning(level, format, args) {\n      // When changing this logic, you might want to also\n      // update consoleWithStackDev.www.js as well.\n      {\n        var hasExistingStack = args.length > 0 && typeof args[args.length - 1] === 'string' && args[args.length - 1].indexOf('\\n    in') === 0;\n\n        if (!hasExistingStack) {\n          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n          var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n          if (stack !== '') {\n            format += '%s';\n            args = args.concat([stack]);\n          }\n        }\n\n        var argsWithFormat = args.map(function (item) {\n          return '' + item;\n        }); // Careful: RN currently depends on this prefix\n\n        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n        // breaks IE9: https://github.com/facebook/react/issues/13610\n        // eslint-disable-next-line react-internal/no-production-logging\n\n        Function.prototype.apply.call(console[level], console, argsWithFormat);\n\n        try {\n          // --- Welcome to debugging React ---\n          // This error was thrown as a convenience so that you can use this stack\n          // to find the callsite that caused this warning to fire.\n          var argIndex = 0;\n          var message = 'Warning: ' + format.replace(/%s/g, function () {\n            return args[argIndex++];\n          });\n          throw new Error(message);\n        } catch (x) {}\n      }\n    } // use dynamic dispatch for CommonJS interop named imports.\n\n\n    var scheduleCallback = Scheduler.unstable_scheduleCallback,\n        IdlePriority = Scheduler.unstable_IdlePriority;\n\n    function createLRU(limit) {\n      var LIMIT = limit; // Circular, doubly-linked list\n\n      var first = null;\n      var size = 0;\n      var cleanUpIsScheduled = false;\n\n      function scheduleCleanUp() {\n        if (cleanUpIsScheduled === false && size > LIMIT) {\n          // The cache size exceeds the limit. Schedule a callback to delete the\n          // least recently used entries.\n          cleanUpIsScheduled = true;\n          scheduleCallback(IdlePriority, cleanUp);\n        }\n      }\n\n      function cleanUp() {\n        cleanUpIsScheduled = false;\n        deleteLeastRecentlyUsedEntries(LIMIT);\n      }\n\n      function deleteLeastRecentlyUsedEntries(targetSize) {\n        // Delete entries from the cache, starting from the end of the list.\n        if (first !== null) {\n          var resolvedFirst = first;\n          var last = resolvedFirst.previous;\n\n          while (size > targetSize && last !== null) {\n            var onDelete = last.onDelete;\n            var previous = last.previous;\n            last.onDelete = null; // Remove from the list\n\n            last.previous = last.next = null;\n\n            if (last === first) {\n              // Reached the head of the list.\n              first = last = null;\n            } else {\n              first.previous = previous;\n              previous.next = first;\n              last = previous;\n            }\n\n            size -= 1; // Call the destroy method after removing the entry from the list. If it\n            // throws, the rest of cache will not be deleted, but it will be in a\n            // valid state.\n\n            onDelete();\n          }\n        }\n      }\n\n      function add(value, onDelete) {\n        var entry = {\n          value: value,\n          onDelete: onDelete,\n          next: null,\n          previous: null\n        };\n\n        if (first === null) {\n          entry.previous = entry.next = entry;\n          first = entry;\n        } else {\n          // Append to head\n          var last = first.previous;\n          last.next = entry;\n          entry.previous = last;\n          first.previous = entry;\n          entry.next = first;\n          first = entry;\n        }\n\n        size += 1;\n        return entry;\n      }\n\n      function update(entry, newValue) {\n        entry.value = newValue;\n      }\n\n      function access(entry) {\n        var next = entry.next;\n\n        if (next !== null) {\n          // Entry already cached\n          var resolvedFirst = first;\n\n          if (first !== entry) {\n            // Remove from current position\n            var previous = entry.previous;\n            previous.next = next;\n            next.previous = previous; // Append to head\n\n            var last = resolvedFirst.previous;\n            last.next = entry;\n            entry.previous = last;\n            resolvedFirst.previous = entry;\n            entry.next = resolvedFirst;\n            first = entry;\n          }\n        }\n\n        scheduleCleanUp();\n        return entry.value;\n      }\n\n      function setLimit(newLimit) {\n        LIMIT = newLimit;\n        scheduleCleanUp();\n      }\n\n      return {\n        add: add,\n        update: update,\n        access: access,\n        setLimit: setLimit\n      };\n    }\n\n    var Pending = 0;\n    var Resolved = 1;\n    var Rejected = 2;\n    var ReactCurrentDispatcher = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;\n\n    function readContext(Context, observedBits) {\n      var dispatcher = ReactCurrentDispatcher.current;\n\n      if (dispatcher === null) {\n        throw new Error('react-cache: read and preload may only be called from within a ' + \"component's render. They are not supported in event handlers or \" + 'lifecycle methods.');\n      }\n\n      return dispatcher.readContext(Context, observedBits);\n    }\n\n    function identityHashFn(input) {\n      {\n        if (typeof input !== 'string' && typeof input !== 'number' && typeof input !== 'boolean' && input !== undefined && input !== null) {\n          error('Invalid key type. Expected a string, number, symbol, or boolean, ' + 'but instead received: %s' + '\\n\\nTo use non-primitive values as keys, you must pass a hash ' + 'function as the second argument to createResource().', input);\n        }\n      }\n      return input;\n    }\n\n    var CACHE_LIMIT = 500;\n    var lru = createLRU(CACHE_LIMIT);\n    var entries = new Map();\n    var CacheContext = React.createContext(null);\n\n    function accessResult(resource, fetch, input, key) {\n      var entriesForResource = entries.get(resource);\n\n      if (entriesForResource === undefined) {\n        entriesForResource = new Map();\n        entries.set(resource, entriesForResource);\n      }\n\n      var entry = entriesForResource.get(key);\n\n      if (entry === undefined) {\n        var thenable = fetch(input);\n        thenable.then(function (value) {\n          if (newResult.status === Pending) {\n            var resolvedResult = newResult;\n            resolvedResult.status = Resolved;\n            resolvedResult.value = value;\n          }\n        }, function (error) {\n          if (newResult.status === Pending) {\n            var rejectedResult = newResult;\n            rejectedResult.status = Rejected;\n            rejectedResult.value = error;\n          }\n        });\n        var newResult = {\n          status: Pending,\n          value: thenable\n        };\n        var newEntry = lru.add(newResult, deleteEntry.bind(null, resource, key));\n        entriesForResource.set(key, newEntry);\n        return newResult;\n      } else {\n        return lru.access(entry);\n      }\n    }\n\n    function deleteEntry(resource, key) {\n      var entriesForResource = entries.get(resource);\n\n      if (entriesForResource !== undefined) {\n        entriesForResource.delete(key);\n\n        if (entriesForResource.size === 0) {\n          entries.delete(resource);\n        }\n      }\n    }\n\n    function unstable_createResource(fetch, maybeHashInput) {\n      var hashInput = maybeHashInput !== undefined ? maybeHashInput : identityHashFn;\n      var resource = {\n        read: function read(input) {\n          // react-cache currently doesn't rely on context, but it may in the\n          // future, so we read anyway to prevent access outside of render.\n          readContext(CacheContext);\n          var key = hashInput(input);\n          var result = accessResult(resource, fetch, input, key);\n\n          switch (result.status) {\n            case Pending:\n              {\n                var suspender = result.value;\n                throw suspender;\n              }\n\n            case Resolved:\n              {\n                var value = result.value;\n                return value;\n              }\n\n            case Rejected:\n              {\n                var error = result.value;\n                throw error;\n              }\n\n            default:\n              // Should be unreachable\n              return undefined;\n          }\n        },\n        preload: function preload(input) {\n          // react-cache currently doesn't rely on context, but it may in the\n          // future, so we read anyway to prevent access outside of render.\n          readContext(CacheContext);\n          var key = hashInput(input);\n          accessResult(resource, fetch, input, key);\n        }\n      };\n      return resource;\n    }\n\n    function unstable_setGlobalCacheLimit(limit) {\n      lru.setLimit(limit);\n    }\n\n    exports.unstable_createResource = unstable_createResource;\n    exports.unstable_setGlobalCacheLimit = unstable_setGlobalCacheLimit;\n  })();\n}","map":null,"metadata":{},"sourceType":"script"}